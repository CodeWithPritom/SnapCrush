<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snapcrush - Face Filter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            touch-action: manipulation;
        }

        /* --- Camera Container --- */
        .camera-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Video and Canvas --- */
        #video, #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        #video {
            display: none;
        }

        /* Ensure proper aspect ratio */
        @media (orientation: portrait) {
            #video, #canvas {
                width: 100%;
                height: auto;
                min-height: 100%;
            }
        }

        @media (orientation: landscape) {
            #video, #canvas {
                width: auto;
                height: 100%;
                min-width: 100%;
            }
        }

        /* --- Snapchat Header --- */
        .header-container {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            left: max(20px, env(safe-area-inset-left));
            z-index: 15;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .snapchat-logo {
            width: 36px;
            height: 36px;
            fill: white;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
        }

        .snapchat-name {
            font-size: clamp(18px, 5vw, 22px);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        /* --- Main UI Overlay Container --- */
        .ui-container {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: max(20px, env(safe-area-inset-left));
            right: max(20px, env(safe-area-inset-right));
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
        }

        /* --- Filter Carousel --- */
        .filter-carousel {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            width: 100%;
            padding: 10px 0;
            scrollbar-width: none;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
        }
        .filter-carousel::-webkit-scrollbar {
            display: none;
        }

        .filter-item {
            flex: 0 0 auto;
            width: clamp(60px, 15vw, 70px);
            height: clamp(60px, 15vw, 70px);
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5em, 6vw, 2em);
            margin: 0 5px;
            backdrop-filter: blur(5px);
            scroll-snap-align: center;
            position: relative;
        }

        .filter-item:hover, .filter-item:active {
            transform: scale(1.05);
        }

        .filter-item.active {
            border-color: #fffc00;
            transform: scale(1.1);
        }

        .filter-item .download-badge {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background: #fffc00;
            color: #000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
        }

        /* --- Action Buttons Bar --- */
        .action-bar {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            padding: 10px 5px;
        }

        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: clamp(24px, 7vw, 28px);
            color: white;
            transition: transform 0.2s ease;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
            padding: 8px;
            flex: 1;
            display: flex;
            justify-content: center;
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        #captureBtn {
            width: clamp(65px, 20vw, 75px);
            height: clamp(65px, 20vw, 75px);
            background-color: white;
            border: 4px solid rgba(0,0,0,0.3);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            filter: none;
            flex: 0 0 auto;
            margin: 0 10px;
        }

        /* --- Status Display --- */
        .status {
            position: absolute;
            top: max(60px, calc(env(safe-area-inset-top) + 40px));
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            border-radius: 15px;
            background: rgba(0,0,0,0.4);
            color: white;
            font-size: clamp(12px, 3.5vw, 14px);
            z-index: 20;
            backdrop-filter: blur(5px);
            text-align: center;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- File Upload Modal --- */
        .file-input-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 30;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.3s ease;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .file-input-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .file-input-section {
            background: #2c2c2e;
            padding: 20px;
            border-radius: 20px;
            width: calc(100% - 40px);
            max-width: 500px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            color: white;
            text-align: center;
            margin: 20px;
        }

        .file-input-section h3 {
            font-size: clamp(18px, 5vw, 22px);
            margin-bottom: 10px;
        }

        .file-input-section p {
            font-size: clamp(14px, 4vw, 16px);
            margin-bottom: 15px;
        }

        .file-input {
            margin: 10px 0;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: clamp(14px, 4vw, 16px);
        }
        .file-input:hover {
            background: rgba(255,255,255,0.2);
            border-color: white;
        }
        .file-input input[type="file"] {
            display: none;
        }

        .preview-images {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .preview-image {
            width: 50px;
            height: 50px;
            object-fit: contain;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preview-image:hover {
            transform: scale(1.1);
            border: 1px solid #fffc00;
        }

        #closeUploadBtn {
            margin-top: 15px;
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            background: #555;
            color: white;
            font-size: clamp(14px, 4vw, 16px);
            cursor: pointer;
            width: 100%;
            max-width: 200px;
        }

        /* Download Filters Modal */
        .download-filters-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 30;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.3s ease;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .download-filters-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .download-filters-section {
            background: #2c2c2e;
            padding: 20px;
            border-radius: 20px;
            width: calc(100% - 40px);
            max-width: 500px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            color: white;
            text-align: center;
            margin: 20px;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .download-filter-item {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .download-filter-item:hover {
            background: rgba(255,255,255,0.2);
        }

        .download-filter-item img {
            width: 100%;
            height: auto;
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .download-filter-item .filter-name {
            font-size: 14px;
            margin-bottom: 5px;
        }

        .apply-btn { /* Changed from download-btn */
            background: #fffc00;
            color: #000;
            border: none;
            border-radius: 15px;
            padding: 5px 10px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="camera-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <div class="header-container">
        <svg class="snapchat-logo" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M22.2,9.3c0-3.3-2-6.5-5.3-6.5c-2.4,0-4.1,1.5-4.9,2.9c-0.8-1.4-2.5-2.9-4.9-2.9C3.8,2.8,1.8,6,1.8,9.3 c0,3.2,1.8,5.1,1.8,5.1s-1.8,2.8,0,5.6c1.2,1.9,3.1,1.9,3.1,1.9s-1.8,2.1,0.2,4.3c0.3,0.3,0.6,0.5,0.8,0.5c0.3,0,0.5-0.1,0.8-0.4 c2.3-2.5,0.2-4.3,0.2-4.3s1.9,0,3.1-1.9c1.8-2.8,0-5.6,0-5.6S22.2,12.5,22.2,9.3z M12,14.2c-2.2,0-4-1.8-4-4s1.8-4,4-4s4,1.8,4,4 S14.2,14.2,12,14.2z"/>
        </svg>
        <span class="snapchat-name">SnapCrush</span>
    </div>

    <div class="status" id="status"><span class="spinner"></span>Initializing...</div>

    <div class="ui-container">
        <div class="filter-carousel" id="filterCarousel">
            <button class="filter-item active" data-filter="none">‚ö™</button>
            <button class="filter-item" data-filter="cat">üê±<span class="download-badge">+</span></button>
            <button class="filter-item" data-filter="dog">üê∂<span class="download-badge">+</span></button>
            <button class="filter-item" data-filter="bunny">üê∞<span class="download-badge">+</span></button>
        </div>

        <div class="action-bar">
            <button class="action-btn" id="downloadBtn" title="Browse & Apply Filters">‚è¨</button>
            <button class="action-btn" id="uploadBtn" title="Manage & Upload Filters">üìÇ</button>
            <button class="action-btn" id="captureBtn" title="Take Photo"></button>
            <button class="action-btn" id="flipCameraBtn" title="Flip Camera">üîÑ</button>
        </div>
    </div>
    
    <!-- File Upload Modal -->
    <div id="fileInputContainer" class="file-input-container hidden">
        <div class.file-input-section">
            <h3>Manage & Upload Filters</h3>
            <p>Click a preview below to remove it. Upload new images to replace a category.</p>
            
            <div class="preview-images" id="previewImages">
                <!-- Loaded filter previews will appear here -->
            </div>

            <div class="file-input">
                <label for="catImages">üê± Add/Replace Cat Filters<input type="file" id="catImages" multiple accept="image/*"></label>
            </div>
            <div class="file-input">
                <label for="dogImages">üê∂ Add/Replace Dog Filters<input type="file" id="dogImages" multiple accept="image/*"></label>
            </div>
            <div class="file-input">
                <label for="bunnyImages">üê∞ Add/Replace Bunny Filters<input type="file" id="bunnyImages" multiple accept="image/*"></label>
            </div>
            
            <button id="closeUploadBtn">Close</button>
        </div>
    </div>
    
    <!-- Download Filters Modal -->
    <div id="downloadFiltersContainer" class="download-filters-container hidden">
        <div class="download-filters-section">
            <h3>Browse & Apply Filters</h3>
            <p>Click 'Apply' to instantly use a new filter.</p>
            
            <div class="filter-grid" id="filterGrid">
                <!-- Filters will be added dynamically -->
            </div>
            
            <button id="closeDownloadBtn" style="margin-top: 20px;">Close</button>
        </div>
    </div>
    
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <script>
        class FaceFilterApp {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: false });
                this.status = document.getElementById('status');
                this.previewContainer = document.getElementById('previewImages');
                this.captureBtn = document.getElementById('captureBtn');
                this.flipCameraBtn = document.getElementById('flipCameraBtn');
                this.uploadBtn = document.getElementById('uploadBtn');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.closeUploadBtn = document.getElementById('closeUploadBtn');
                this.closeDownloadBtn = document.getElementById('closeDownloadBtn');
                this.fileInputContainer = document.getElementById('fileInputContainer');
                this.downloadFiltersContainer = document.getElementById('downloadFiltersContainer');
                this.filterGrid = document.getElementById('filterGrid');
                this.cameraContainer = document.querySelector('.camera-container');
                
                this.currentFilter = 'none';
                this.currentFacingMode = 'user';
                this.faceMesh = null;
                this.camera = null;
                this.filterImages = { cat: [], dog: [], bunny: [] };
                this.isInitialized = false;
                this.lastFrameTime = 0;
                this.frameInterval = 1000 / 30;
                this.rafId = null;
                this.videoAspectRatio = 0;
                this.canvasAspectRatio = 0;
                
                this.demoFilters = {
                    cat: [
                        { name: "Blushy Kitty", url: "./src/filters/1 (1).png" },
                        { name: "Laser Whiskers", url: "./src/filters/1 (6).png" },
                        { name: "The OG Catfish", url: "./src/filters/1 (7).png" }
                    ],
                    dog: [
                        { name: "Classic Dog", url: "./src/filters/13 (1).png" },
                        { name: "Doodle Dog", url: "./src/filters/1 (12).png" }
                    ],
                    bunny: [
                        { name: "Bunny", url: "./src/filters/1 (8).png" },
                        { name: "Bunny", url: "./src/filters/13 (2).png" }
                    ]
                };

                this.onResults = this.onResults.bind(this);
                this.processFrame = this.processFrame.bind(this);
                this.handleResize = this.handleResize.bind(this);
                this.adjustVideoSize = this.adjustVideoSize.bind(this);
                this.initializeApp();
            }

            async initializeApp() {
                try {
                    await this.preloadCustomFilter();
                    this.setupFileInputs();
                    this.setupDownloadFilters();
                    await this.setupMediaPipe();
                    await this.setupCamera(this.currentFacingMode);
                    this.setupEventListeners();
                    window.addEventListener('resize', this.handleResize);
                    this.updateStatus('‚úÖ Ready! Select a filter or download more.');
                    this.isInitialized = true;
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.updateStatus(`‚ùå Error: ${error.message}`);
                }
            }
            
            async preloadCustomFilter() {
                try {
                    const catImg = await this.loadImage('path/folder/cat.png');
                    this.filterImages.cat.push(catImg);
                    this.addPreviewImage(catImg, 'cat');
                    this.updateStatus('‚úÖ Preloaded demo cat filter');
                } catch (error) {
                    console.warn('Could not preload custom filter from "path/folder/cat.png". It may not exist.');
                }
            }
            
            // --- MODIFIED FUNCTION ---
            // Now implements "replace on click" behavior
            setupDownloadFilters() {
                this.filterGrid.innerHTML = '';
                
                Object.entries(this.demoFilters).forEach(([filterType, filters]) => {
                    filters.forEach(filter => {
                        const filterItem = document.createElement('div');
                        filterItem.className = 'download-filter-item';
                        filterItem.innerHTML = `
                            <img src="${filter.url}" alt="${filter.name}" onerror="this.style.display='none'">
                            <div class="filter-name">${filter.name}</div>
                            <button class="apply-btn" data-url="${filter.url}" data-filter="${filterType}">Apply</button>
                        `;
                        this.filterGrid.appendChild(filterItem);
                    });
                });
                
                this.filterGrid.querySelectorAll('.apply-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const url = e.target.dataset.url;
                        const filterType = e.target.dataset.filter;
                        this.updateStatus(`Applying ${filterType} filter...`);
                        
                        try {
                            const img = await this.loadImage(url);
                            
                            // --- REPLACE BEHAVIOR ---
                            // Replace the entire array for this filter type with the new image.
                            this.filterImages[filterType] = [img];
                            
                            // Update the management panel to reflect this replacement.
                            this.updatePreviewPanel(filterType);
                            
                            // Programmatically click the carousel item to switch to it.
                            const carouselButton = document.querySelector(`.filter-item[data-filter="${filterType}"]`);
                            if (carouselButton) {
                                carouselButton.click();
                            }
                            
                            // Close the modal and show success.
                            this.toggleDownloadPanel(false);
                            this.updateStatus(`‚úÖ New ${filterType} filter applied!`);

                        } catch (error) {
                            console.error('Error applying filter:', error);
                            this.updateStatus('‚ùå Failed to apply filter.');
                        }
                    });
                });
            }

            // --- NEW HELPER FUNCTION ---
            // Updates the preview panel to accurately reflect the current state of a filter category.
            updatePreviewPanel(filterType) {
                // 1. Remove all existing preview images for this category.
                this.previewContainer.querySelectorAll(`[data-filter-type="${filterType}"]`).forEach(el => el.remove());

                // 2. Add the current images back. After replacement, this will often be just one.
                this.filterImages[filterType].forEach(img => {
                    this.addPreviewImage(img, filterType);
                });
            }

            loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            handleResize() {
                this.adjustVideoSize();
            }

            adjustVideoSize() {
                if (!this.video.videoWidth || !this.video.videoHeight) return;
                
                this.videoAspectRatio = this.video.videoWidth / this.video.videoHeight;
                const containerAspectRatio = this.cameraContainer.clientWidth / this.cameraContainer.clientHeight;
                
                if (containerAspectRatio > this.videoAspectRatio) {
                    this.canvas.style.width = 'auto';
                    this.canvas.style.height = '100%';
                } else {
                    this.canvas.style.width = '100%';
                    this.canvas.style.height = 'auto';
                }
                
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
            }

            setupFileInputs() {
                ['catImages', 'dogImages', 'bunnyImages'].forEach(id => {
                    const input = document.getElementById(id);
                    const filterType = id.replace('Images', '');
                    input.addEventListener('change', (event) => this.handleFileUpload(event, filterType));
                });
            }

            async handleFileUpload(event, filterType) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;
                
                this.updateStatus(`Replacing ${filterType} images...`);
                try {
                    this.filterImages[filterType] = [];
                    this.previewContainer.querySelectorAll(`[data-filter-type="${filterType}"]`).forEach(el => el.remove());

                    const filesToLoad = files.slice(0, 3);
                    
                    const loadPromises = filesToLoad.map(file => {
                        if (file.type.startsWith('image/')) {
                            return this.loadImageFromFile(file).then(img => {
                                this.filterImages[filterType].push(img);
                                this.addPreviewImage(img, filterType);
                            });
                        }
                        return Promise.resolve();
                    });

                    await Promise.all(loadPromises);
                    this.updateStatus(`‚úÖ Replaced ${filterType} images.`);
                } catch (error) {
                    console.error('Error loading images:', error);
                    this.updateStatus('‚ùå Error loading images.');
                }
            }

            loadImageFromFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }
            
            addPreviewImage(img, filterType) {
                const previewImg = document.createElement('img');
                previewImg.src = img.src;
                previewImg.className = 'preview-image';
                previewImg.title = `Click to remove this ${filterType} overlay`;
                previewImg.dataset.filterType = filterType;

                previewImg.addEventListener('click', () => {
                    this.removeFilterImage(filterType, img.src);
                });

                this.previewContainer.appendChild(previewImg);
            }
            
            removeFilterImage(filterType, imgSrc) {
                const imageIndex = this.filterImages[filterType].findIndex(img => img.src === imgSrc);

                if (imageIndex > -1) {
                    this.filterImages[filterType].splice(imageIndex, 1);
                    const previewImgEl = this.previewContainer.querySelector(`img[src="${imgSrc}"]`);
                    if (previewImgEl) {
                        previewImgEl.remove();
                    }
                    this.updateStatus(`‚úÖ ${filterType} overlay removed.`);
                }
            }

            async setupMediaPipe() {
                this.updateStatus('Loading face detection model...');
                this.faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                
                this.faceMesh.setOptions({
                    maxNumFaces: 1, 
                    refineLandmarks: false,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6,
                    selfieMode: true
                });
                
                this.faceMesh.onResults(this.onResults);
            }

            async setupCamera(facingMode) {
                this.updateStatus('Accessing camera...');
                if (this.camera) this.camera.stop();
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                    this.rafId = null;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode,
                            frameRate: { ideal: 30 }
                        }
                    });
                    this.video.srcObject = stream;

                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.canvas.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                            this.adjustVideoSize();
                            
                            this.camera = new Camera(this.video, {
                                onFrame: async () => {
                                    const now = performance.now();
                                    if (now - this.lastFrameTime >= this.frameInterval) {
                                        this.lastFrameTime = now;
                                        await this.faceMesh.send({ image: this.video });
                                    }
                                },
                                width: this.video.videoWidth, 
                                height: this.video.videoHeight
                            });
                            this.camera.start();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error('Camera access denied or not available.');
                }
            }

            setupEventListeners() {
                const filterCarousel = document.getElementById('filterCarousel');
                filterCarousel.addEventListener('click', (e) => {
                    const button = e.target.closest('.filter-item');
                    if (button) {
                        filterCarousel.querySelector('.active').classList.remove('active');
                        button.classList.add('active');
                        this.currentFilter = button.dataset.filter;

                        if (this.currentFilter !== 'none' && this.filterImages[this.currentFilter].length === 0) {
                            this.updateStatus(`‚ö†Ô∏è No ${this.currentFilter} images loaded. Apply or upload one first!`);
                        }
                    }
                });
                
                this.captureBtn.addEventListener('click', () => this.takePicture());
                this.flipCameraBtn.addEventListener('click', () => this.switchCamera());
                this.uploadBtn.addEventListener('click', () => this.toggleUploadPanel(true));
                this.downloadBtn.addEventListener('click', () => this.toggleDownloadPanel(true));
                this.closeUploadBtn.addEventListener('click', () => this.toggleUploadPanel(false));
                this.closeDownloadBtn.addEventListener('click', () => this.toggleDownloadPanel(false));
                
                const touchHandler = (e) => {
                    e.preventDefault();
                    e.target.click();
                };
                
                [this.captureBtn, this.flipCameraBtn, this.uploadBtn, this.downloadBtn].forEach(btn => {
                    btn.addEventListener('touchstart', touchHandler, { passive: false });
                });
            }
            
            toggleUploadPanel(show) {
                this.fileInputContainer.classList.toggle('hidden', !show);
                if (show) {
                    this.downloadFiltersContainer.classList.add('hidden');
                }
            }
            
            toggleDownloadPanel(show) {
                this.downloadFiltersContainer.classList.toggle('hidden', !show);
                if (show) {
                    this.fileInputContainer.classList.add('hidden');
                }
            }
            
            async switchCamera() {
                this.currentFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
                this.updateStatus(`Switching to ${this.currentFacingMode} camera...`);
                try {
                    await this.setupCamera(this.currentFacingMode);
                    this.updateStatus('‚úÖ Camera switched!');
                } catch (error) {
                    this.updateStatus(`‚ùå Failed to switch camera. ${error.message}`);
                    this.currentFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
                }
            }
            
            takePicture() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(this.canvas, 0, 0);
                
                const link = document.createElement('a');
                link.download = `snapchat-filter-photo-${Date.now()}.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                
                this.updateStatus('‚úÖ Photo saved!');
            }

            onResults(results) {
                if (!this.isInitialized) return;
                
                this.rafId = requestAnimationFrame(() => {
                    this.processFrame(results);
                });
            }
            
            processFrame(results) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.videoAspectRatio > (this.canvas.width / this.canvas.height)) {
                    const scaledHeight = this.canvas.width / this.videoAspectRatio;
                    this.ctx.drawImage(results.image, 0, (this.canvas.height - scaledHeight) / 2, this.canvas.width, scaledHeight);
                } else {
                    const scaledWidth = this.canvas.height * this.videoAspectRatio;
                    this.ctx.drawImage(results.image, (this.canvas.width - scaledWidth) / 2, 0, scaledWidth, this.canvas.height);
                }

                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0 && 
                    this.currentFilter !== 'none' && this.filterImages[this.currentFilter].length > 0) {
                    this.applyFilter(results.multiFaceLandmarks[0]);
                }
            }
            
            applyFilter(landmarks) {
                const images = this.filterImages[this.currentFilter];
                if (!images || images.length === 0) return;

                const leftEye = landmarks[33];
                const rightEye = landmarks[263];
                const noseTip = landmarks[1];
                const leftFace = landmarks[234];
                const rightFace = landmarks[454];

                const angle = Math.atan2((rightEye.y - leftEye.y) * this.canvas.height, (rightEye.x - leftEye.x) * this.canvas.width);
                const faceWidth = Math.hypot((rightFace.x - leftFace.x) * this.canvas.width, (rightFace.y - leftFace.y) * this.canvas.height);
                
                const facePoints = {
                    noseTip: { x: noseTip.x * this.canvas.width, y: noseTip.y * this.canvas.height },
                    betweenEyes: { x: ((leftEye.x + rightEye.x) / 2) * this.canvas.width, y: ((leftEye.y + rightEye.y) / 2) * this.canvas.height },
                };
                
                const imagesToDraw = images.slice(0, 3);
                imagesToDraw.forEach((img, index) => {
                    this.drawOverlayImage(img, facePoints, faceWidth, angle, index);
                });
            }

            drawOverlayImage(img, facePoints, faceWidth, angle, imageIndex) {
                this.ctx.save();
                
                let scale, anchor, offsetX, offsetY, customScale;
                
                if (imageIndex === 0) {
                    anchor = facePoints.betweenEyes;
                    customScale = 1.6;
                    offsetX = 0;
                    offsetY = -faceWidth * 0.25;
                } else if (imageIndex === 1) {
                    anchor = facePoints.betweenEyes;
                    customScale = 1.3;
                    offsetX = 0;
                    offsetY = faceWidth * 0.15;
                } else {
                    anchor = facePoints.noseTip;
                    customScale = 0.5;
                    const placementAngle = (imageIndex - 2) * (Math.PI / 2) + Math.PI / 4;
                    offsetX = Math.cos(placementAngle) * faceWidth * 0.5;
                    offsetY = Math.sin(placementAngle) * faceWidth * 0.5;
                }

                scale = (faceWidth / img.width) * customScale;
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                
                this.ctx.translate(anchor.x, anchor.y);
                this.ctx.rotate(angle);
                this.ctx.drawImage(img, offsetX - scaledWidth / 2, offsetY - scaledHeight / 2, scaledWidth, scaledHeight);
                this.ctx.restore();
            }

            updateStatus(message) {
                const spinner = message.startsWith('‚úÖ') || message.startsWith('‚ùå') || message.startsWith('‚ö†Ô∏è') 
                    ? '' 
                    : '<span class="spinner"></span>';
                this.status.innerHTML = spinner + message;
                
                if (!message.includes('‚ùå') && !message.includes('‚ö†Ô∏è')) {
                    setTimeout(() => {
                        if (this.status.innerHTML === spinner + message) {
                            this.status.textContent = '';
                        }
                    }, 3000);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const app = new FaceFilterApp();
            
            window.addEventListener('beforeunload', () => {
                if (app.video.srcObject) {
                    app.video.srcObject.getTracks().forEach(track => track.stop());
                }
                if (app.rafId) {
                    cancelAnimationFrame(app.rafId);
                }
            });
        });
    </script>
</body>
</html>
